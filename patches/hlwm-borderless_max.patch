From 94bcb21ce2e3168377bd364071673a26a3ebfb64 Mon Sep 17 00:00:00 2001
From: baskerville <nihilhill@gmail.com>
Date: Sat, 9 Jun 2012 18:52:42 +0200
Subject: [PATCH] Added an option: 'borderless_max'

---
 doc/herbstluftwm.txt |    4 ++++
 src/clientlist.c     |   18 ++++++++++++------
 src/clientlist.h     |    1 +
 src/layout.c         |    9 +++++++++
 src/settings.c       |    1 +
 5 files changed, 27 insertions(+), 6 deletions(-)

diff --git a/doc/herbstluftwm.txt b/doc/herbstluftwm.txt
index e72d32b..ecdeff7 100644
--- a/doc/herbstluftwm.txt
+++ b/doc/herbstluftwm.txt
@@ -614,6 +614,10 @@ gapless_grid (Integer)::
     this frame. If unset, then the last client has the same size as all other
     clients in this frame.
 
+borderless_max (Integer)::
+    This setting is active when there's only one frame in the current tag.
+    If set, it will remove window borders for the max layout.
+
 focus_follows_shift (Integer)::
     If set, focus stays in the window, if window is shifted to another frame.
     If unset, focus stays in the frame.
diff --git a/src/clientlist.c b/src/clientlist.c
index 5a4204b..856a8f0 100644
--- a/src/clientlist.c
+++ b/src/clientlist.c
@@ -52,6 +52,7 @@ static HSClient* create_client() {
     hc->urgent = false;
     hc->fullscreen = false;
     hc->pseudotile = false;
+    hc->borderless = false;
     return hc;
 }
 
@@ -326,16 +327,21 @@ void client_resize(HSClient* client, XRectangle rect) {
         rect.height = size.height;
     }
     if (RECTANGLE_EQUALS(client->last_size, rect)
+        && !client->borderless
         && client->last_border_width == *g_window_border_width) {
         return;
     }
     client->last_size = rect;
-    client->last_border_width = *g_window_border_width;
-
-    // apply border width
-    rect.width -= *g_window_border_width * 2;
-    rect.height -= *g_window_border_width * 2;
-    XSetWindowBorderWidth(g_display, win, *g_window_border_width);
+    if (client->borderless) {
+        XSetWindowBorderWidth(g_display, win, 0);
+        client->last_border_width = 0;
+    } else {
+        // apply border width
+        rect.width -= *g_window_border_width * 2;
+        rect.height -= *g_window_border_width * 2;
+        XSetWindowBorderWidth(g_display, win, *g_window_border_width);
+        client->last_border_width = *g_window_border_width;
+    }
     XMoveResizeWindow(g_display, win, rect.x, rect.y, rect.width, rect.height);
     //// send new size to client
     //// WHY SHOULD I? -> faster? only one call?
diff --git a/src/clientlist.h b/src/clientlist.h
index 1a66f07..2006725 100644
--- a/src/clientlist.h
+++ b/src/clientlist.h
@@ -26,6 +26,7 @@ typedef struct HSClient {
     bool        urgent;
     bool        fullscreen;
     bool        pseudotile; // only move client but don't resize (if possible)
+    bool        borderless;
     int         pid;
 } HSClient;
 
diff --git a/src/layout.c b/src/layout.c
index 522535f..136fa0b 100644
--- a/src/layout.c
+++ b/src/layout.c
@@ -34,6 +34,7 @@ int* g_focus_follows_shift;
 int* g_frame_bg_transparent;
 int* g_direction_external_only;
 int* g_gapless_grid;
+int* g_borderless_max;
 unsigned long g_frame_border_active_color;
 unsigned long g_frame_border_normal_color;
 unsigned long g_frame_bg_active_color;
@@ -65,6 +66,7 @@ static void fetch_frame_colors() {
     g_default_frame_layout = &(settings_find("default_frame_layout")->value.i);
     g_direction_external_only = &(settings_find("default_direction_external_only")->value.i);
     g_gapless_grid = &(settings_find("gapless_grid")->value.i);
+    g_borderless_max = &(settings_find("borderless_max")->value.i);
     *g_default_frame_layout = CLAMP(*g_default_frame_layout, 0, LAYOUT_COUNT - 1);
     char* str = settings_find("frame_border_normal_color")->value.s;
     g_frame_border_normal_color = getcolor(str);
@@ -644,6 +646,7 @@ void frame_apply_client_layout_linear(HSFrame* frame, XRectangle rect, bool vert
     }
     for (int i = 0; i < count; i++) {
         HSClient* client = get_client_from_window(buf[i]);
+        client->borderless = false;
         // add the space, if count doesnot divide frameheight without remainder
         cur.height += (i == count-1) ? last_step_y : 0;
         cur.width += (i == count-1) ? last_step_x : 0;
@@ -668,6 +671,11 @@ void frame_apply_client_layout_max(HSFrame* frame, XRectangle rect) {
     int selection = frame->content.clients.selection;
     for (int i = 0; i < count; i++) {
         HSClient* client = get_client_from_window(buf[i]);
+        if (*g_borderless_max && !g_cur_frame->parent && !client->pseudotile) {
+            client->borderless = true;
+        } else {
+            client->borderless = false;
+        }
         client_setup_border(client, (g_cur_frame == frame) && (i == selection));
         client_resize_tiling(client, rect);
         if (i == selection) {
@@ -724,6 +732,7 @@ void frame_apply_client_layout_grid(HSFrame* frame, XRectangle rect) {
 
             // apply size
             HSClient* client = get_client_from_window(buf[i]);
+            client->borderless = false;
             client_setup_border(client, (g_cur_frame == frame) && (i == selection));
             client_resize_tiling(client, cur);
             cur.x += width;
diff --git a/src/settings.c b/src/settings.c
index 2b09dad..3444bc3 100644
--- a/src/settings.c
+++ b/src/settings.c
@@ -61,6 +61,7 @@ SettingsPair g_settings[] = {
     SET_INT(    "raise_on_focus",                  0,           NULL        ),
     SET_INT(    "raise_on_click",                  1,           NULL        ),
     SET_INT(    "gapless_grid",                    1,           RELAYOUT    ),
+    SET_INT(    "borderless_max",                  0,           FR_COLORS   ),
     SET_INT(    "monitors_locked",                 0,           LOCK_CHANGED),
     SET_STRING( "tree_style",                      "*| +`--.",  FR_COLORS   ),
 };
-- 
1.7.10.4

