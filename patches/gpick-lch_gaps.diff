diff --git a/source/gtk/ColorComponent.cpp b/source/gtk/ColorComponent.cpp
--- a/source/gtk/ColorComponent.cpp
+++ b/source/gtk/ColorComponent.cpp
@@ -529,24 +529,24 @@
 
 			color_get_chromatic_adaptation_matrix(color_get_reference(ns->lab_illuminant, ns->lab_observer), color_get_reference(REFERENCE_ILLUMINANT_D65, REFERENCE_OBSERVER_2), &adaptation_matrix);
 
-			for (i = 0; i < 3; ++i){
-				color_copy(&ns->color, &c[i]);
-			}
-			for (i = 0; i <= steps; ++i){
-				c[0].lch.L = (i / steps) * ns->range[0] + ns->offset[0];
-        color_lch_to_rgb(&c[0], &rgb_points[0 * (int(steps) + 1) + i], color_get_reference(ns->lab_illuminant, ns->lab_observer), color_get_inverted_sRGB_transformation_matrix(), &adaptation_matrix);
-				color_rgb_normalize(&rgb_points[0 * (int(steps) + 1) + i]);
-			}
+			Color white;
+			white.ma[0] = white.ma[1] = white.ma[2] = 0.0;
+			for (j = 0; j < 3; ++j){
+				color_copy(&ns->color, &c[j]);
 
-			for (i = 0; i <= steps; ++i){
-				c[1].lch.C = (i / steps) * ns->range[1] + ns->offset[1];
-        color_lch_to_rgb(&c[1], &rgb_points[1 * (int(steps) + 1) + i], color_get_reference(ns->lab_illuminant, ns->lab_observer), color_get_inverted_sRGB_transformation_matrix(), &adaptation_matrix);
-				color_rgb_normalize(&rgb_points[1 * (int(steps) + 1) + i]);
-			}
-			for (i = 0; i <= steps; ++i){
-				c[2].lch.h = (i / steps) * ns->range[2] + ns->offset[2];
-        color_lch_to_rgb(&c[2], &rgb_points[2 * (int(steps) + 1) + i], color_get_reference(ns->lab_illuminant, ns->lab_observer), color_get_inverted_sRGB_transformation_matrix(), &adaptation_matrix);
-				color_rgb_normalize(&rgb_points[2 * (int(steps) + 1) + i]);
+				for (i = 0; i <= steps; ++i){
+					c[j].ma[j] = (i / steps) * ns->range[j] + ns->offset[j];
+					color_lch_to_rgb(&c[j], &rgb_points[j * (int(steps) + 1) + i], color_get_reference(ns->lab_illuminant, ns->lab_observer), color_get_inverted_sRGB_transformation_matrix(), &adaptation_matrix);
+					if (rgb_points[j * (int(steps) + 1) + i].ma[0] > 1.0
+					 || rgb_points[j * (int(steps) + 1) + i].ma[1] > 1.0
+					 || rgb_points[j * (int(steps) + 1) + i].ma[2] > 1.0
+					 || rgb_points[j * (int(steps) + 1) + i].ma[0] < 0.0
+					 || rgb_points[j * (int(steps) + 1) + i].ma[1] < 0.0
+					 || rgb_points[j * (int(steps) + 1) + i].ma[2] < 0.0){
+						color_copy(&white, &rgb_points[j * (int(steps) + 1) + i]);
+					}
+					color_rgb_normalize(&rgb_points[j * (int(steps) + 1) + i]);
+				}
 			}
 			for (i = 0; i < surface_width; ++i){
 
